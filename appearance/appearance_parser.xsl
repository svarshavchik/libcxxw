<?xml version='1.0'?>

<!--

Copyright 2019 Double Precision, Inc.
See COPYING for distribution information.

Stylesheet for creating a parser for appearance objects whose members are
defined in appearance/*.xml

-->

<xsl:stylesheet
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

  <xsl:output method="text" />

  <xsl:template match="/root">
    <xsl:text>/* Automatically generated by appearance_parser.xsl */
</xsl:text>

    <xsl:for-each select="appearance">
      <xsl:call-template name="appearance" />
    </xsl:for-each>

    <xsl:text>
LIBCXXW_NAMESPACE_START

const_appearance uicompiler::compile_appearance(const ui::parser_lock &amp;parent,
                                                const std::string &amp;type)
{
</xsl:text>
    auto based_on=parent->get_any_attribute("from");

    <xsl:for-each select="appearance">
      <xsl:text>
    if (type == "</xsl:text>
      <xsl:value-of select="name" />
      <xsl:text>")
        return get_appearance(parent, get_appearance_base(</xsl:text>
      <xsl:value-of select="name" />
      <xsl:text>_appearance::base::</xsl:text>
      <xsl:value-of select="default[position() = 1]" />
      <xsl:text>(), based_on));
</xsl:text>
    </xsl:for-each>
    <xsl:text>
    unknown_appearance_type(parent->get_any_attribute("id"), type);
}
LIBCXXW_NAMESPACE_END

</xsl:text>
  </xsl:template>

  <xsl:template name="appearance">
    <xsl:text>
#include "x/w/</xsl:text>
    <xsl:value-of select="name"/>
    <xsl:text>_appearance.H"

LIBCXXW_NAMESPACE_START

template class appearance_wrapper&lt;const_</xsl:text>
    <xsl:value-of select="name"/>
    <xsl:text>_appearance&gt;;

inline void uicompiler::generate(const generate_info &amp;info,
    const </xsl:text>
    <xsl:value-of select="name"/>
    <xsl:text>_appearance &amp;appearance)
{
    auto &amp;[parent, lock, xpath]=info;

</xsl:text>

    <xsl:for-each select="field/vector">
      <xsl:if test="position()=1">
	<xsl:text>    {
        auto vector=parent-&gt;clone();
</xsl:text>
      </xsl:if>
      <xsl:text>
        </xsl:text>
      <xsl:if test="position()=1">
	<xsl:text>auto </xsl:text>
      </xsl:if>

      <xsl:text>xpath=vector-&gt;get_xpath("</xsl:text>
      <xsl:value-of select="../name" />
      <xsl:text>");
        </xsl:text>
      <xsl:if test="position()=1">
	<xsl:text>auto </xsl:text>
      </xsl:if>
      <xsl:text>n=xpath-&gt;count();

        xpath=vector->get_xpath("</xsl:text>
      <xsl:value-of select="../name" />
      <xsl:text>/reset");

        n -= xpath->count();
	appearance-&gt;</xsl:text><xsl:value-of select="../name"/>
	    <xsl:text>.reserve(n);
</xsl:text>
       <xsl:if test="position() = count(../vector)">
	 <xsl:text>    }

</xsl:text>
       </xsl:if>
    </xsl:for-each>

    <xsl:text>    size_t n=xpath->count();

    for (size_t i=0; i&lt;n; ++i)
    {
        xpath->to_node(i+1);

        auto name=lock-&gt;name();

</xsl:text>

    <xsl:for-each select="field">
      <xsl:text>        </xsl:text>
      <xsl:if test="position() &gt; 1">
	<xsl:text>else </xsl:text>
      </xsl:if>
      <xsl:text>if (name==&#34;</xsl:text>
      <xsl:value-of select="name" />
      <xsl:text>&#34;)
        {
            </xsl:text>
      <xsl:if test="vector">
	<xsl:text>auto xpath=lock->get_xpath("reset");

            if (xpath-&gt;count() &gt; 0)
            {
                if (xpath-&gt;count() &gt; 1)
                {
                    duplicate_reset("</xsl:text>
                    <xsl:value-of select="name" />
                    <xsl:text>");
                }
                appearance-&gt;</xsl:text>
                <xsl:value-of select="name"/>
		<xsl:text>.clear();
            }
            else </xsl:text>
      </xsl:if>
      <xsl:if test="optional">
	<xsl:text>auto xpath=lock->get_xpath("reset");

            if (xpath-&gt;count() &gt; 0)
                appearance-&gt;</xsl:text>
        <xsl:value-of select="name" />
	<xsl:text>.reset();
            else
                </xsl:text>
      </xsl:if>
      <xsl:text>appearance-&gt;</xsl:text>
      <xsl:value-of select="name" />
      <xsl:choose>
	<xsl:when test="vector">
	  <xsl:text>.push_back(</xsl:text>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:text>=</xsl:text>
	</xsl:otherwise>
      </xsl:choose>
      <xsl:choose>
	<xsl:when test="ref">
	  <xsl:text>get_compiled_appearance&lt;const_</xsl:text>
	  <xsl:value-of select="ref" />
	  <xsl:text>_appearance&gt;(lock->get_text())</xsl:text>
	</xsl:when>
	<xsl:when test="type='std::string'">
	  <xsl:text>lock-&gt;get_text()</xsl:text>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:text>to_</xsl:text>
	  <xsl:value-of select="type" />
	  <xsl:text>(lock, "</xsl:text>
	  <xsl:value-of select="type" />
	  <xsl:text>", "</xsl:text>
	  <xsl:value-of select="name" />
	  <xsl:text>")</xsl:text>
	</xsl:otherwise>
      </xsl:choose>
      <xsl:if test="vector">
	<xsl:text>)</xsl:text>
      </xsl:if>
      <xsl:text>;
        }
</xsl:text>
    </xsl:for-each>
    <xsl:text>        else unknown_appearance_node(&#34;</xsl:text>
    <xsl:value-of select="name" />
    <xsl:text>&#34;, name);
    }
}

const_</xsl:text>
    <xsl:value-of select="name"/>
    <xsl:text>_appearance uicompiler::get_appearance_base(const const_</xsl:text>
    <xsl:value-of select="name"/>
    <xsl:text>_appearance &amp;base_appearance,
        const std::string &amp;based_on)
{
    if (based_on.empty())
        return base_appearance;

</xsl:text>
    <xsl:choose>
      <xsl:when test="default">
	<xsl:for-each select="default">
	  <xsl:text>    </xsl:text>
	  <xsl:if test="position() &gt; 1">
	    <xsl:text>else </xsl:text>
	  </xsl:if>
	  <xsl:text>if (based_on == "</xsl:text>
	  <xsl:value-of select="." />
	  <xsl:text>")
            return </xsl:text>
	  <xsl:value-of select="../name" />
	  <xsl:text>_appearance::base::</xsl:text>
	  <xsl:value-of select="." />
	  <xsl:text>();
</xsl:text>
	</xsl:for-each>
	<xsl:text>    else </xsl:text>
      </xsl:when>
      <xsl:otherwise>
	<xsl:text>    </xsl:text>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:text>return get_compiled_appearance&lt;const_</xsl:text>
    <xsl:value-of select="name" />
    <xsl:text>_appearance&gt;(based_on);
</xsl:text>
<xsl:text>}

const_</xsl:text>
    <xsl:value-of select="name"/>
    <xsl:text>_appearance uicompiler::get_appearance(const ui::parser_lock &amp;parent,
    const const_</xsl:text>
    <xsl:value-of select="name"/>
    <xsl:text>_appearance &amp;appearance)
{
    auto lock=parent-&gt;clone();
    auto xpath=lock-&gt;get_xpath("*");

    if (xpath-&gt;count() == 0)
        return appearance; // No need to clone it. Optimization.

    return appearance-&gt;modify([&amp;, this]
                  (const auto &amp;appearance)
                  {
                      generate({parent, lock, xpath}, appearance);
                  });
}

LIBCXXW_NAMESPACE_END
</xsl:text>
  </xsl:template>
</xsl:stylesheet>
