<!--

Copyright 2014-2017 Double Precision, Inc.
See COPYING for distribution information.

-->

<preface id="index">
  <title>&app;</title>
  <section id="intro">
    <title>Introduction</title>

    <para>
      &appshort; is the first X widget toolkit with a
      C++17 <acronym>API</acronym>. After several years of private
      development it has reached beta quality, and
      is now publicly available.
      This toolkit is based on the &libcxx; library, see
      <xref linkend="INSTALL" /> for more information.
      Notable features:
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  Uses modern C++17 language features; such as:
	  using lambdas to handle events like pointer clicks and other
	  user activity; overloaded, variadic-parameter methods offering
	  alternative means of configuring various display elements; and
	  other C++1z features.
	</para>
      </listitem>

      <listitem>
	<para>
	  Implements typical traditional UI elements: labels, text input fields,
	  lists, combo boxes, menus, and dialogs. The UI elements support
	  basic theming, including scaling -- adjusting the
	  scaled size of the UI.
	</para>

	<para>
	  The default UI elements are scalable, using a
	  <link linkend="sxg">library-specific
	    scalable graphic format</link>. Alternatively, an application
	  may load its own <acronym>GIF</acronym>, <acronym>PNG</acronym>,
	  or <acronym>JPG</acronym> fixed-size images.
	</para>
      </listitem>

      <listitem>
	<para>
	  All display elements have full keyboard navigation, where
	  possible. Even scrollbars have keyboard-based navigation.
	</para>
      </listitem>

      <listitem>
	<para>
	  Unlike other high-level toolkits,
	  &app; does not require the application to use an event-driven
	  design. &app; manages an internal execution thread that handles all
	  X events. The main application
	  thread can be working on a dedicated, long-running task that
	  blocks all pointer and keyboard events, but the background thread
	  continues to update the display elements, and process X events
	  as needed, all by itself.
	</para>
      </listitem>

      <listitem>
	<para>
	  All display elements are
	  &libcxx;'s reference-counted objects. There are no explicit methods
	  to destroy input fields, buttons, and other display elements.
	  Each display element is a reference-counted object, and
	  when the last
	  reference to the object goes out of scope, and gets destroyed, this
	  results in the corresponding display element getting destroyed.
	</para>

	<para>
	  And because parent display elements hold references to their
	  child display elements, removing a parent display element from its
	  container automatically removes and destroys all elements it contains.
	</para>
      </listitem>

      <listitem>
	<para>
	  &app; is a compositing toolkit. The underlying video hardware
	  must implement the X RENDER extension. This should supported by all
	  modern video hardware.
	</para>
      </listitem>

      <listitem>
	<para>
	  Anti-aliased fonts get rendered by the Freetype library.
	</para>
      </listitem>
    </itemizedlist>

    <para>
      &app; is free software, distributed under the terms of the
      <link linkend="COPYING">GPL, version 3</link>.
    </para>
  </section>

  &install;

  <section id="libcxx_overview">
    <title>&libcxx; overview</title>

    <para>
      &app; is built using the &libcxx; library, a library of classes and
      templates based on reference-counted objects. Some existing familiarity
      with &libcxx; will be helpful in understanding how to use
      &appshort;'s classes, but is not strictly necessary.
      A brief overview follows.
    </para>

    <para>
      All &appshort; classes and templates are defined in the
      <literal>&ns;::w</literal> namespace.
    </para>

    <section id="referencehier">
      <title>References</title>

      <para>
	It's important to understand the relationship between the various
	objects and classes.

	All classes and templates, like
	<ulink url="&link-typedef-x--w-connection;"><classname>&ns;::w::connection</classname></ulink>
	and
	<ulink url="&link-typedef-x--w-screen;"><classname>&ns;::w::screen</classname></ulink>
	are reference-counted objects, based on
	<ulink url="&refobj;"><classname>&ns;::ref</classname> and
	  <classname>&ns;::ptr</classname></ulink>.
	<classname>&ns;::w::connection</classname>,
	<classname>&ns;::w::screen</classname> and others,
	are just reference handles, similar to
	<classname>std::shared_ptr</classname>.
      </para>

      <para>
	The &app; takes care of creating the actual, underlying objects, and
	when the last reference, last handle, to the underlying object goes
	out of scope, the underlying object gets destroyed. This includes
	both the explicit references, and the internal references the underlying
	objects have to each other.
      </para>

      <para>
	Except as stated, the &app;'s internal references are generally
	as follows:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    The &app; does not maintain its own internal references to top
	    level display elements, like
	    <ulink url="&link-typedef-x--w-main-window;"><classname>&ns;::w::main_window</classname></ulink>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <classname>&ns;::w::main_window</classname> holds a reference on
	    its
	    <classname>&ns;::w::screen</classname>, which holds a refernece on
	    its
	    <classname>&ns;::w::connection</classname>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    A <ulink url="&link-typedef-x--w-container;">container</ulink>
	    holds a reference to its
	    <ulink url="&link-typedef-x--w-layoutmanager;">layout
	      manager</ulink>, and the layout manager holds reference to
	    all elements in the container.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	A main window is a container. Typically, an application
	creates its main window, and stores its
	<classname>&ns;::w::main_window</classname> somewhere. The application
	procedes and creates the various display elements, putting them in their
	containers, which now hold a reference on them.
      </para>

      <para>
	In this manner, all references end up being rooted in their main
	window object.
	When the application destroys its
	<classname>&ns;::w::main_window</classname> handle, the cascading
	effect from that destroys all display elements and internal objects.
      </para>

      <para>
	This works correctly as long as no other references to any display
	elements, or other related objects, exist. If the application has
	a reference to a display element, or some other &app; object that's
	tied to the main application window, directly, or indirectly, this is
	going to prevent the main application window from getting properly
	destroyed.
      </para>
    </section>

    <section id="connection_thread">
      <title>The connection thread</title>

      <para>
	As mentioned briefly in the introduction, the &app; uses a separate
	thread for the connection with the display server. &app; takes care
	of starting the connection thread. The connection thread gets
	automatically stopped when the last top level window gets destroyed.
      </para>

      <para>
	The connection thread takes care of updating the display, and
	processing internal display protocol messages. The connection thread
	may also end up executing an application-supplied callback in the form
	of a lambda or some other callable object.
      </para>

      <para>
	The connection thread resumes its normal duties after the application
	callback returns. Application callbacks should not get bogged down
	with long-running tasks, as this will result in the application
	window appearing to be frozen. Callbacks should be minimal, and consist
	of little more than sending a message of some kind, or setting a flag.
      </para>

      <para>
	Different callbacks get installed or uninstalled in different ways.
	Due to asynchronous nature of the connection thread, the application
	must be prepared for the callback to be executing at the same time
	the application requests the callback to be turned off or uninstalled;
	or shortly thereafter before the callback's deactivation gets finalized.
      </para>

      <para>
	As such, application's callbacks should safely capture anything they
	need by value (subject to <link linkend="callbackrefs">restrictions
	  on creating circular references</link>).
	&libcxx;'s reference-counted objects (which are,
	incidentally, are used to build the &app; itself) are an excellent
	suggestion. The callback and the main application coordinate their
	mutual dependency through some refernece-counted object. After both
	the application gets rid of its reference, and the callback gets
	uninstalled, with the captured reference going out of scope and
	getting destroyed, the underlying reference-counted object which was
	used for this coordination gets destroyed automatically.
      </para>
    </section>
  </section>
</preface>

<!--
Local Variables:
mode: sgml
sgml-parent-document: ("book.xml" "book" "preface")
End:
-->
