<!--

Copyright 2014-2017 Double Precision, Inc.
See COPYING for distribution information.

-->

<preface id="index">
  <title>&app;</title>
  <section id="intro">
    <title>Introduction</title>

    <?dbhtml-include href="demoreel.inc.html"?>

    <para>
      &appshort; is an optional add-on library to &libcxx;
      that implements a basic X user interface toolkit with a modern
      C++17 <acronym>API</acronym> and without any dependencies on large
      Gnome (GTK) or QT libraries. The only dependencies are
      toolkit-independent
      libraries that are not tied to any particular desktop environment.
      See <xref linkend="INSTALL" /> for more information.
      &appshort; aims to make it possible to quickly implement a simple,
      basic, no-frills X user interface in C++.
      Notable features:
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  Uses modern C++17 language features:
	  lambdas handle events like mouse button clicks and other
	  user activity; overloaded, variadic-parameter methods offering
	  alternative means of configuring various display elements; and
	  other C++17 features.
	</para>
      </listitem>

      <listitem>
	<para>
	  Implements basic, traditional UI elements: labels, text input fields,
	  lists, combo boxes, menus, and dialogs. The UI elements support
	  basic theming, including scaling -- adjusting the
	  scaled size of the UI.
	</para>

	<para>
	  The default UI elements are scalable, using a
	  <link linkend="sxg">library-specific
	    scalable graphic format</link>. Alternatively, an application
	  may load its own <acronym>GIF</acronym>, <acronym>PNG</acronym>,
	  or <acronym>JPG</acronym> fixed-size images.
	</para>
      </listitem>

      <listitem>
	<para>
	  All display elements have full keyboard navigation, where
	  possible. Even scrollbars have keyboard-based navigation.
	</para>
      </listitem>

      <listitem>
	<para>
	  Unlike other high-level toolkits,
	  &app; does not require the application to use an event-driven
	  design. &app; run an internal execution thread that handles all
	  X events. The main application
	  thread can be working on a dedicated, long-running task that
	  blocks all pointer and keyboard events, but the background thread
	  continues to update the display elements, and process X events
	  as needed, all by itself.
	</para>
      </listitem>

      <listitem>
	<para>
	  All display elements are
	  &libcxx;'s reference-counted objects (based on smart pointers).
	  There are no explicit methods
	  to destroy input fields, buttons, and other display elements.
	  Each display element is a reference-counted object, with
	  containers holding references to the elements in the container.
	  Removing an element from the container results in the last
	  reference to the object going out of scope, which destroyes it.
	  This
	  results in the corresponding display element getting destroyed.
	</para>
      </listitem>

      <listitem>
	<para>
	  &app; is a compositing toolkit. The underlying video hardware
	  must implement the X RENDER extension. This should supported by all
	  modern video hardware.
	</para>
      </listitem>

      <listitem>
	<para>
	  Anti-aliased fonts get rendered by the Freetype library.
	</para>
      </listitem>
    </itemizedlist>

    <para>
      &app; is free software, distributed under the terms of the
      <link linkend="COPYING">GPL, version 3</link>.
    </para>
  </section>

  &install;

  <section id="libcxx_overview">
    <title>&libcxx; overview</title>

    <para>
      &app; is built using the &libcxx; library, a library of classes and
      templates based on reference-counted objects. Some existing familiarity
      with &libcxx; will be helpful in understanding how to use
      &appshort;'s classes, but is not strictly necessary.
      A brief overview follows.
    </para>

    <para>
      All &appshort; classes and templates are defined in the
      <literal>&ns;::w</literal> namespace.
    </para>

    <section id="referencehier">
      <title>References</title>

      <para>
	It's important to understand the relationship between the various
	objects and classes.

	All classes and templates, like
	<ulink url="&link-typedef-x--w-connection;"><classname>&ns;::w::connection</classname></ulink>
	and
	<ulink url="&link-typedef-x--w-screen;"><classname>&ns;::w::screen</classname></ulink>
	are reference-counted objects, based on
	<ulink url="&refobj;"><classname>&ns;::ref</classname> and
	  <classname>&ns;::ptr</classname></ulink>.
	<classname>&ns;::w::connection</classname>,
	<classname>&ns;::w::screen</classname> and others,
	are just reference handles, similar to
	<classname>std::shared_ptr</classname>.
      </para>

      <para>
	The &app; takes care of creating the actual, underlying objects, and
	when the last reference, last handle, to the underlying object goes
	out of scope, the underlying object gets destroyed. This includes
	both the explicit references, and the internal references the underlying
	objects have to each other.
      </para>

      <para>
	Except as stated, the &app;'s internal references are generally
	as follows:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    The &app; does not maintain its own internal references to top
	    level display elements, like
	    <ulink url="&link-typedef-x--w-main-window;"><classname>&ns;::w::main_window</classname></ulink>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <classname>&ns;::w::main_window</classname> holds a reference on
	    its
	    <classname>&ns;::w::screen</classname>, which holds a refernece on
	    its
	    <classname>&ns;::w::connection</classname>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    A <ulink url="&link-typedef-x--w-container;">container</ulink>
	    holds a reference to its
	    <ulink url="&link-typedef-x--w-layoutmanager;">layout
	      manager</ulink>, and the layout manager holds reference to
	    all elements in the container.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	A main window is a container. Typically, an application
	creates its main window, and stores its
	<classname>&ns;::w::main_window</classname> somewhere. The application
	procedes and creates the various display elements, putting them in their
	containers, which now hold a reference on them.
      </para>

      <para>
	In this manner, all references end up being rooted in their main
	window object.
	When the application destroys its
	<classname>&ns;::w::main_window</classname> handle, the cascading
	effect from that destroys all display elements and internal objects.
      </para>

      <para>
	This works correctly as long as no other references to any display
	elements, or other related objects, exist. If the application has
	a reference to a display element, or some other &app; object that's
	tied to the main application window, directly, or indirectly, this is
	going to prevent the main application window from getting properly
	destroyed.
      </para>
    </section>
  </section>
</preface>

<!--
Local Variables:
mode: sgml
sgml-parent-document: ("book.xml" "book" "preface")
End:
-->
