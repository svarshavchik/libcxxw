<!--

Copyright 2017 Double Precision, Inc.
See COPYING for distribution information.

-->

<chapter id="dialogs">
  <title>Dialogs</title>

  <mediaobject>
    <imageobject>
      <imagedata fileref="dialogs.png" format="PNG"
		 contentwidth="700px" contentdepth="156px" />
    </imageobject>
    <textobject>
      <phrase>
	Dialogs
      </phrase>
    </textobject>
    <caption>
      <para>
	<filename>menu.C</filename> from <xref linkend="menu" />
	also demonstrates how to create dialogs. Dialogs are stand-alone,
	top level windows, represented by
	<ulink url="&link-typedef-x--w-dialog;"><classname>&ns;::w::dialog</classname></ulink>
	objects.
      </para>
    </caption>
  </mediaobject>

  <para>
    An <ulink url="&link-typedef-x--w-dialog;"><classname>&ns;::w::dialog</classname></ulink>
    is similar to an <link linkend="concepts"><classname>&ns;::w::main_window</classname></link>.
    While <classname>&ns;::w::main_window</classname>s
    get created by themselves,
    <classname>&ns;::w::dialog</classname>s get created by one of the methods
    from an existing
    <classname>&ns;::w::main_window</classname> or another
    <classname>&ns;::w::dialog</classname> (which is a subclass of a
    <classname>&ns;::w::main_window</classname> and inherits all of its
    methods):
  </para>

  <para>
    Several methods create dialogs with a standard,
    theme-defined layout:
  </para>

  <variablelist>
    <varlistentry>
      <term><methodname>create_ok_dialog</methodname>()</term>
      <listitem>
	<para>
	  A standard dialog with an <quote>Ok</quote> button.
	</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><methodname>create_ok_cancel_dialog</methodname>()</term>
      <listitem>
	<para>
	  A standard dialog with <quote>Ok</quote> and
	  <quote>Cancel</quote> buttons.
	</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><methodname>create_input_dialog</methodname>()</term>
      <listitem>
	<para>
	  A standard dialog with <quote>Ok</quote> and
	  <quote>Cancel</quote> buttons, and an
	  <link linkend="inputfields"><classname>&ns;::w::input_field</classname></link>.
	</para>
      </listitem>
    </varlistentry>
  </variablelist>

  <para>
    The first parameter to these methods is a dialog identifier, which
    is a <classname>std::string</classname>, and serves as an identifying
    label.
    Each
    <classname>&ns;::w::main_window</classname> (or a
    <classname>&ns;::w::dialog</classname>_)can create more than one dialog,
    as long as each dialog has a unique identifier label.
    Creating another dialog with the same identifier label replaces
    the existing dialog with that label.
  </para>

  <para>
    Dialog identifiers are opaque, unique labels. For future use, dialog
    identifier labels should use the following naming conventions.
    Applications should use identifier labels formatted as Internet
    hostnames or E-mail addresses, using domain names that belong to the
    application. An application developed by
    <literal>example.com</literal>
    can use <quote>dialog1@example.com</quote>, or
    <quote>confirmation@app1.example.com</quote>, as an example.
    <quote>@libcxx</quote> labels are reserved for &appshort;'s use.
  </para>

  <para>
    The next parameter to
    <methodname>create_ok_dialog</methodname>(), or
    <methodname>create_ok_cancel_dialog</methodname>() and others,
    is the name of a small icon
    displayed on the left side of the dialog. Currently, the possible
    choices are:
    <quote>alert</quote>, <quote>stop</quote>, and <quote>message</quote>.
    The remaining parameters vary, and include:
  </para>

  <itemizedlist>
    <listitem>
      <para>
	A &callback; that receives a &factory; for creating the contents
	of the dialog. This factory callback must create exactly one
	display element. Dialogs typically contain brief messages, created
	with <methodname>create_label</methodname>(), but may contain
	arbitrary display elements. This is done by having the
	factory callback create a &container; and then creating the
	display elements in the new container.
      </para>

      <para>
	<methodname>create_input_field</methodname>()'s factory callback
	creates the display element that appears to the left of the
	input field.
      </para>
    </listitem>
    <listitem>
      <para>
	&callback;s that get invoked when <quote>Ok</quote> or
	<quote>Cancel</quote> buttons are pressed.
	<methodname>create_input_field</methodname>()'s
	<quote>Ok</quote> callback receives an additional parameter with
	the <classname>&ns;::input_field</classname>.
      </para>
    </listitem>

    <listitem>
      <para>
	Additional parameters for
	<methodname>create_input_field</methodname>(): the initial
	contents of the input field, and its
	<classname>&ns;::w::input_field_config</classname> (the
	same parameters as the ones that get passed to
	<link linkend="inputfields"><methodname>create_input_field</methodname></link>().
      </para>
    </listitem>

    <listitem>
      <para>
	Optional <ulink url="&link-x--w--text-param;"><classname>&ns;::w::text_params</classname></ulink>s
	that override the label for the
	<quote>Ok</quote> and
	<quote>Cancel</quote> buttons.
      </para>
    </listitem>

    <listitem>
      <para>
	An optional <classname>bool</classname> that specifies whether the
	new dialog is modal.
      </para>
    </listitem>
  </itemizedlist>

  <para>
    Invoking a created dialog's
    <methodname>show_all</methodname>() method makes it visible.
    The buttons in dialogs created by standard methods automatically
    <methodname>hide</methodname>() themselves before
    invoking the callbacks.
    Depending on the window manager, the dialogs may have a title and
    a close button, like a normal application window.
    <link linkend="menu"><filename>menu.C</filename></link> uses
    <methodname>set_window_title</methodname>() to give its dialogs a
    reasonable title, in that case. A close button, if present, results
    in the same action as the <quote>Cancel</quote> button
    (or just the <quote>Ok</quote> button in
    <methodname>create_ok_dialog</methodname>()'s case).
  </para>

  <section id="modaldialogs">
    <title>Modal dialogs</title>

    <para>
      A modal dialog temporarily disables its main application window
      while the modal dialog is visible. All keyboard and pointer events
      get ignored by the main application window if at least one of its
      modal dialogs is visible. Hiding (or completely destroying) all of
      its modal dialogs restores normal keyboard and pointer event
      processing.
      On most display servers the main application window gets a visible
      shade overlayed on top of its contents to indicate that it's disabled
      by an active modal dialog.
    </para>

    <para>
      Modeless dialogs have no effect on the dialog's main window. Both
      the dialog itself and the main window continue to process keyborad
      and pointer events normally, all the time.
    </para>

    <para>
      A modal dialog created from another dialog disables only the dialog
      its created from, and has no effect on the main window.
      Modal dialogs block keyboard and pointer events
      only from the immediate window or the dialog they get created from.
    </para>
  </section>

  <section id="dialogrefs">
    <title>The creating <classname>x::w::main_window</classname> (or
      a <classname>x::w::main_window</classname>) owns references on its
      dialogs</title>

    <para>
      A <link linkend="concepts">fundamental concept</link> of the &app;
      is that all its objects are reference-counted objects. All references
      to the object must go out of scope and get destroyed before the
      underlying objects' destructors get automatically invoked;
      and all main windows must be destroyed in order for the library
      to properly clean up and disconnect from the display server.
    </para>

    <para>
      In main windows, container elements
      <link linkend="containerrefs">own references to the
	display elements in the container</link>. This applies to dialogs
      too. Their parent main window (or their parent dialog) owns a reference
      on all of its dialogs.
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
std::unordered_set&lt;std::string&gt; dialogs=main_window->dialogs();</programlisting>
      </informalexample>
    </blockquote>

    <para>
       <filename>menu.C</filename>
       gives an example of using <methodname>dialogs</methodname>(), which
       returns all identifier labels for all dialogs that the
       <classname>&ns;::w::main_window</classname> (or the
       <classname>&ns;::w::dialog</classname>) owns.
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
help_question_type.on_activate=
    [main_window=x::make_weak_capture(main_window)]
    (const x::w::menuitem_activation_info &amp;ignore)
    {
         main_window.get([&amp;]
                         (const auto &amp;main_window) {
                             main_window-&gt;get_dialog
                                ("help_question")->show_all();
                         });
    };</programlisting>
      </informalexample>
    </blockquote>

    <para>
      <filename>menu.C</filename> creates several dialogs, like
      <quote>help_question</quote>, for a main window with a menu which
      open the various dialogs.
      <methodname>get_dialog</methodname>() takes a dialog identifier and
      returns the previously-created dialog with that identifier label.
      The &callback;s that get installed for each menu item use it to
      locate the appropriate dialog, and make it visible.
    </para>

    <para>
      The dialog's button merely hide their dialog, they don't destroy it,
      since their parent main window owns a reference to its dialogs. As
      such, when the menu item gets selected again it simply
      <methodname>show_all</methodname>()s the same dialog, making it
      visible again.
    </para>

    <para>
      The only way to permanently destroy a dialog is by using
      <methodname>remove_dialog</methodname>(); and because the parent
      main window owns references on its dialogs, if the main window's last
      reference goes out of scope and it gets destroyed (as part of normal
      application termination), its dialogs get destroyed too.
    </para>

    <para>
      This also means that, as shown in the above example, &callback;'s
      must capture only weak reference to their parent main window (or
      parent dialog), because the main window (or the parent dialog)
      owns (directly or indirectly) references to all elements in the
      main window (or the dialog), including the menu item with the callback,
      so the weak capture is required to avoid a circular reference.
    </para>
  </section>

  <section id="customdialogs">
    <title>Custom dialogs</title>

    <para>
      Standard dialogs created by
      <methodname>create_ok_dialog</methodname>(),
      <methodname>create_ok_cancel_dialog</methodname>(), and other methods,
      use a predetermined layout, and content, specified by the current
      display theme. <methodname>create_dialog</methodname>() creates a
      completely empty dialog, ready to be filled with its content:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
#include &lt;&ns;/w/dialog.H&gt;
#include &lt;&ns;/w/gridlayoutmanager.H&gt;

&ns;::w::dialog d=mw-&gt;create_dialog
    ("dialog_id",
     []
     (const &ns;::w::dialog &amp;d)
     {
           &ns;::w::gridlayoutmanager lm=d-&gt;get_layoutmanager();

           // ...
     },
     &ns;::w::new_gridlayoutmanager{},
     true);</programlisting>
      </informalexample>
    </blockquote>

    <para>
      The first parameter is the dialog's &creator;.
      The second parameter specifies the dialog's &layoutmanager;.
      The third optional parameter specifies whether the new dialog is modal.
    </para>
  </section>
</chapter>
<!--
Local Variables:
mode: sgml
sgml-parent-document: ("book.xml" "book" "chapter")
End:
-->
