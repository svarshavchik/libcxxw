<!--

Copyright 2017-2018 Double Precision, Inc.
See COPYING for distribution information.

-->

<chapter id="helloworld">
  <title>Hello world!</title>

  <mediaobject>
    <imageobject>
      <imagedata fileref="helloworld.png" format="PNG"
		 contentwidth="452px" contentdepth="472px" />
    </imageobject>
    <textobject>
      <phrase>
	Hello World!
      </phrase>
    </textobject>
    <caption>
      <para>
	The following <quote>hello world</quote> program displays
	the above application window.
      </para>
    </caption>
  </mediaobject>

  <blockquote>
    <title><ulink url="examples/helloworld.C">helloworld.C</ulink></title>

    <informalexample>
      <programlisting><xi:include href="../examples/helloworld.C" parse="text" xmlns:xi="http://www.w3.org/2001/XInclude" /></programlisting>
    </informalexample>
  </blockquote>

  <section id="examples">
    <title>Building example programs</title>

    <para>
      The above program comes from the <ulink url="examples">examples
	directory</ulink>. The GNU toolchain
      (<application>autoconf</application>,
      <application>automake</application>, and
      <application>gmake</application>)
      is required to build &app;'s example programs:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
cd examples
autoreconf
./configure
make</programlisting>
      </informalexample>
    </blockquote>
  </section>

  <section id="concepts">
    <title>Basic concepts</title>

    <para>
      The <link linkend="helloworld"><filename>helloworld.C</filename></link>
      example demonstrates several basic concepts used by &app;:
    </para>

    <section id="refobjelements">
      <title>Display elements are reference-counted objects with smart pointers</title>
      <para>
	<filename>helloworld.C</filename> creates an
	<ulink url="&link-typedef-x--w-main-window;"><classname>&ns;::w::main_window</classname></ulink>,
	an object that represents the main application window.
	<classname>&ns;::w::main_window</classname> is a smart pointer.
	&appshort; does not use C++ library's
	<classname>std::shared_ptr</classname>,
	but &libcxx;'s own
	<ulink url="/ref.html"><classname>&ns;::ref</classname></ulink>
	which works in a similar way (but has additional features).
	This documentation uses the term <quote>reference</quote> to
	refer to &libcxx;'s <classname>&ns;::ref</classname> smart
	pointers.
      </para>

      <para>
	The application does not need to take an explicit step to destroy
	the main window, or any other display object. When its
	<classname>&ns;::ref</classname> goes out of scope and gets destroyed
	the display element gets destroyed and removed.
      </para>
    </section>

    <section id="containerrefs">
      <title>Containers own references to the elements in the container</title>
      <para>
	<classname>&ns;::w::main_window</classname> is a
	&container;,
	a display element that contains other display elements.
	They can be individual display elements like buttons and input
	fields, or they can be other containers with their own display
	elements. Each container is, itself, a display element.
      </para>

      <para>
	Naturally, containers hold references on the elements in the
	container. Removing an element from the container gets rid of the
	container's reference on the element. Normally, no other references
	remain and all resources used by the display element are released.
      </para>

      <para>
	The application creates all display elements, and it's possible
	for the application to retain its own reference to the display
	element. The application must make sure that it no longer holds
	its own reference on a display element when it gets removed from
	the container;
	or when any of its parent containers get removed from their respective
	container.
      </para>

      <para>
	Since <classname>&ns;::w::main_window</classname> is a top-level
	application window, nothing else holds a reference to it.
	<link linkend="helloworld"><filename>helloworld.C</filename></link>
	creates an <classname>&ns;::w::main_window</classname> in its
	<function>testlabel</function>() function. There are no other
	references to it, and when it returns the last reference to the
	main window goes out of scope, it gets destroyed and removed from
	the display.
      </para>

      <para>
	<link linkend="helloworld"><filename>helloworld.C</filename></link>'s
	<function>create_label</function>() creates a
	label
	display element in the main window, but
	<function>testlabel</function>() does not store this reference
	itself, leaving the only reference to the label in its
	main window container. When <function>testlabel</function>()
	returns, the last reference to the main window goes away and
	the underlying object gets destroyed. Since that object held
	the only reference to the label display element object, the
	label display element object gets destroyed as well.
      </para>

      <para>
	In this manner, removing a container recursively removes and
	destroyes everything in the container, recursively. However if
	the application retained its own reference to the label object,
	this would prevent everything from getting destroyed properly,
	and all resources released.
      </para>
    </section>

    <section id="connthread">
      <title>Connection threads and callbacks</title>

      <para>
	&app; starts an internal execution thread that manages the
	connection to the X server. Unlike other X toolkits, &app; does
	not force the application into an event-driven design pattern.
	&app; takes care of automatically starting the internal
	execution thread, and stopping it after the last top level
	window object gets destroyed.
      </para>

      <para>
	In
	<link linkend="helloworld"><filename>helloworld.C</filename></link>,
	returning from <function>testlabel</function>() destroys the
	<classname>&ns;::w::main_window</classname>, which stops
	the execution thread. However the execution thread does not get
	stopped immediately, and it continues to perform some final
	cleanup duties, while <function>main</function>() wraps up its
	own responsibilities.
      </para>

      <para>
	<link linkend="helloworld"><filename>helloworld.C</filename></link>
	shows an example of waiting until the connection thread terminates
	and the connection to the X server gets closed. This uses
	various classes from the &libcxx; parent library:
      </para>

      <orderedlist>
	<listitem>
	  <para>
	    <link linkend="helloworld"><filename>helloworld.C</filename></link>
	    uses <function>connection_mcguffin</function> to retrieve
	    a <ulink url="/ondestroy.html">mcguffin</ulink> for the underlying
	    X protocol connection.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    An <ulink url="/ondestroyguard"><classname>&ns;::destroy_callback::base::guard</classname></ulink>
	    object, from the base &libcxx; library,
	    gets declared before the top level window. A such
	    the guard object gets destroyed last.
	    The guard object takes the mcguffin, and the guard object's
	    destructor waits until the mcguffin gets destroyed,
	    indicating that the X protocol connection object was destroyed
	    and the execution thread stopped.
	  </para>

	  <para>
	    In this manner, while destroying the guard object, when
	    returning from <function>testlabel</function>(), the main
	    execution thread stops and waits for &app;'s internal
	    execution thread to finish up, and disconnect from the
	    X server.
	  </para>
	</listitem>
      </orderedlist>
    </section>

    <section id="callbacks">
      <title>Callbacks</title>

      <para>
	A callback is a lambda or a callable object that &appshort;
	executes in response to an event of some kind.
      </para>

      <para>
	<link linkend="helloworld"><filename>helloworld.C</filename></link>,
	installs two callbacks:
	the <function>on_disconnect</function>() lambda gets invoked if
	the connection to the X server was unexpectedly disconnected; and
	<classname>&ns;::w::main_window</classname>'s
	<function>on_delete</function>() lambda gets invoked when the
	main window's <quote>Close</quote> button gets clicked.
      </para>

      <para>
	<function>on_delete</function>() callback's first parameter,
	<quote><literal>ONLY IN_THREAD</literal></quote>.
	indicates it gets invoked from the connection-thread,
	as explained in <xref linkend="connection_thread" />.
	Although <function>on_disconnect</function>()'s callback also
	gets invoked from the connection-thread its invocation indicates
	that the connection-thread is no longer functional, so it does
	not get the
	<quote><literal>ONLY IN_THREAD</literal></quote> parameter.
      </para>

      <para>
	In all cases, callbacks, in general,
	should not engage in lengthy, time-consuming tasks. Until the
	callback returns, the internal connection thread will be unable to
	process any additional X protocol messages. Callbacks should be
	limited to simple tasks, such as sending messages to the main
	application thread, to execute the actual task at hand.
      </para>

      <para>
	To effectively do this in a thread safe manner, the recommended
	approach is:
      </para>

      <orderedlist>
	<listitem>
	  <para>
	    Use &libcxx;'s <classname>&ns;::ref</classname>s and
	    <classname>&ns;::obj</classname>s to construct
	    reference-counted, thread-safe objects. See &libcxx;'s
	    documentation for more
	    information.
	  </para>

	  <para>
	    <link linkend="helloworld"><filename>helloworld.C</filename></link>,
	    and other example programs,
	    implements <function>on_delete</function>()
	    using a simple
	    <ulink url="examples/close_flag.H"><classname>close_flag</classname></ulink>
	    object, containing a <classname>bool</classname> flag,
	    a mutex, and a condition variable.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Capture the shared flag objects by value.
	    <link linkend="helloworld"><filename>helloworld.C</filename></link>'s
	    <function>on_delete</function>()
	    lambda callback captures the <classname>close_flag</classname>
	    by value.
	    Clicking the window's close button results in the lambda acquiring
	    the mutex, setting the flag, and signaling the condition
	    variable.
	  </para>

	  <para>
	    The main execution thread only needs to acquire
	    <classname>close_flag</classname>'s mutex, and wait on the
	    condition variable until the flag gets set.
	  </para>

	  <para>
	    The underlying &libcxx;'s smart pointers take care of destroying
	    the <classname>close_flag</classname> by themselves.
	  </para>
	</listitem>
      </orderedlist>

      <section id="callbackrefs">
	<title>Special rules for captured references in callbacks</title>

	<para>
	  As explained in <xref linkend="containerrefs" />,
	  containers own references to all elements in the container.
	  It is possible to attach additional application data to
	  any display element, including containers; and
	  <xref linkend="appdata" /> explains that the attached
	  application data cannot have references to any parent (of the
	  display element the data is attached to). This results in a
	  circular reference because the parent has its own direct
	  or indirect reference to the element in the container; and
	  &app; uses reference-counted objects for all display elements,
	  which get destroyed automatically, but only when the last reference
	  to each object goes out of scope.
	</para>

	<para>
	  References captured by lambdas that are used as callbacks have
	  more restrictions. Capturing
	  <emphasis>either</emphasis> a parent or a child element
	  results in an internal circular reference.
	  Capturing a reference to an element not in the parent or the
	  child element hierarchy is fine.
	</para>

	<para>
	  There are several ways to correctly capture references to other
	  display elements for use in callbacks. One way is to use
	  weak captures, see <xref linkend="callbackweakcaptures" />
	  in <xref linkend="gridlayoutmanager" /> for
	  an example.
	  Another design pattern is for callbacks to capture a
	  message queue-like object, and use the message queue to send a
	  message to the main execution thread:
	</para>

	<blockquote>
	  <informalexample>
	    <programlisting><![CDATA[
main_window->on_delete([queue]
    (ONLY IN_THREAD,
     const x::w::busy &amp;ignore)
    {
        queue->message([]
            (const x::w::main_window &main_window, const appdata_t &appdata)
	    {
                appdata->close_flag=true;
            })
    });]]></programlisting>
	  </informalexample>
	</blockquote>

	<para>
	  In this example the captured <varname>queue</varname> is
	  a simple <classname>&ns;::ref</classname> to a thread-safe
	  queue-like object, perhaps a <classname>std::deque</classname> of
	  <classname>std::function</classname>s.
	  The messages take the form of type-erased
	  <classname>std::function</classname> lambdas. The main execution
	  thread runs a loop that waits for and executes application
	  messages:
	</para>

	<blockquote>
	  <informalexample>
	    <programlisting><![CDATA[
while (!appdata->close_flag)
    appdata->queue->next_message(main_window, appdata);
]]></programlisting>
	  </informalexample>
	</blockquote>

	<para>
	  The thread-safe queue is a member of the
	  application data object, and contains no other references.
	  <methodname>next_message</methodname>() waits for the next message
	  and invokes the function, passing to it the main window object,
	  and the application data object. The application data object can
	  simply be attached <link linkend="appdata">as the main window's
	    <varname>appdata</varname></link> and the executed lambda could
	  fetch it, itself. This simply saves a step.
	</para>

	<para>
	  No rules are broken here. The callback lambda only captures a
	  reference to the message queue. It does not capture a reference to
	  anything else. When executed, the main window object and the
	  application data object get passed to it, as parameters.
	  The message lambdas always get invoked by the main execution thread,
	  so no locking is required for setting the
	  <varname>close_flag</varname> which only the main execution thread
	  checks, as well. And even though the callback cannot capture
	  references to its parent or child element, it has full access to
	  all display elements, from the passed-in main window element;
	  or from any references in the application data object.
	</para>

	<para>
	  The only thing that the main execution thread needs to be careful
	  with is to make sure that its own reference to the application
	  data object goes out of scope before the main window display element
	  goes out of scope and gets destroyed.
	</para>

	<para>
	  An example of this message-based design found is given in
	  <xref linkend="busy" />.
	</para>
      </section>
    </section>

    <section id="container">
      <title>Containers</title>

      <para>
	<ulink url="&link-typedef-x--w-main-window;"><classname>&ns;::w::main_window</classname></ulink>
	is an example of a container.
	A container is a display element which contains other display
	elements, and a &layoutmanager; that controls them.
	<link linkend="helloworld"><filename>helloworld.C</filename></link>
	creates a
	<classname>&ns;::w::main_window</classname> that has a
	label element.
      </para>

      <para>
	<classname>&ns;::w::main_window</classname>'s
	<function>create</function>() static method returns a new
	<classname>&ns;::w::main_window</classname>.
	Other containers get created in various other ways.
      </para>
    </section>

    <section id="creator">
      <title>Creator lambdas</title>

      <para>
	Creator lambdas initialize the contents of a new display element,
	including containers. For containers,
	a lambda gets passed as a parameter to a function or a method
	that creates a new container, like a
	<link linkend="factory">factory</link>'s
	<methodname>create_container</methodname>() or
	<methodname>create_focusable_container</methodname>().
	A creator also gets passed to a
	<classname>&ns;::w::main_window</classname>'s
	<function>create</function>(). In general, a creator
	lambda gets called just before the function or the method
	returns the new container:
      </para>

      <blockquote>
	<informalexample>
	  <programlisting><![CDATA[
	auto main_window=x::w::main_window
		::create([]
			 (const x::w::main_window &main_window)
			 {
                            // ...
]]>

        x::w::container c=factory->create_container(
	         []
	         (const x::w::container &amp;c)
                 {
                      // ...
</programlisting>
	</informalexample>
      </blockquote>

      <para>
	The creator lambda gets the new display element as its parameter.
	This is the same object that's going returned from the function or
	a method that's creating it. The creator lambda gets invoked just
	before that function or method returns.
      </para>

      <para>
	The purpose of the creator lambda is to initialize the new container.
	<link linkend="helloworld"><filename>helloworld.C</filename></link>
	initializes the main window, in the creator, by adding a new label
	to it.
      </para>

      <para>
	Observe that
	<link linkend="helloworld"><filename>helloworld.C</filename></link>'s
	window gets automatically sized for the label.
	The creator lambda is an optimization.
	The size of a new container gets computed after the creator lambda
	returns, but before the newly-created container itself gets returned
	to the application.
      </para>

      <para>
	<link linkend="helloworld"><filename>helloworld.C</filename></link>
	could do nothing in its creator lambda, and then add the label to
	the
	<classname>&ns;::w::main_window</classname> itself.
	However, this will be less efficient. Initially the main window's
	size gets calculated as empty, there's nothing in it. After the
	label gets added the size of the main window must be recalculated
	again.
      </para>

      <para>
	Populating the container in its creator lambda avoids doing this
	extra recalculation, and is more efficient.
      </para>
    </section>

    <section id="layoutmanager">
      <title>Layout managers</title>

      <para>
	A container is a display element that contains other display elements.
	The main application window is a container.
	Each container has a <quote>layout manager</quote>. The layout
	manager arranges the display elements in the container.
	A container's <methodname>get_layoutmanager</methodname>() method
	returns a
	<ulink url="&link-typedef-x--w-layoutmanager;"><classname>&ns;::w::layoutmanager</classname></ulink>,
	which is just a reference to a base layout manager class.
	There are several layout managers that get derived from an
	<classname>&ns;::w::layoutmanager</classname>'s base class:
      </para>

      <variablelist>
	<varlistentry>
	  <term>
	    <link linkend="gridlayoutmanager"><classname>&ns;::w::gridlayoutmanager</classname></link>
	  </term>
	  <listitem>
	    <para>
	      The default, generic layout manager that positions its display
	      elements in a rectangular grid, or a table, with optional
	      borders.
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
	    <ulink url="&link-typedef-x--w-borderlayoutmanager;"><classname>&ns;::w::borderlayoutmanager</classname></ulink>
	  </term>
	  <listitem>
	    <para>
	      This layout manager draws a border around a single display
	      element, the only display element in this layout manager's
	      container.
	    </para>

	    <para>
	      This layout manager is optimized for this purpose. The grid
	      layout manager is capable of drawing borders around the elements
	      in the rectangular grid too, and manage multiple elements.
	      The grid layout manager's complexity results in non-trivial
	      overhead, and when all that's needed is a simple border
	      around an element the border layout manager does the job faster
	      and with less cost.
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
	    <link linkend="menu"><classname>&ns;::w::menubarlayoutmanager</classname></link>
	  </term>
	  <listitem>
	    <para>
	      Each display element in this container represents a title
	      in the main application window's menu bar.
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
	    <link linkend="list"><classname>&ns;::w::listlayoutmanager</classname></link>
	  </term>
	  <listitem>
	    <para>
	      A crafty impostor that is not a really true layout manager.
	      It doesn't contain discrete display elements, but plain
	      text strings.
	      The list layout manager is available for selection lists,
	      and it also gets called into duty for
	      <link linkend="menulayoutmanager">pop-up menus</link>, and
	      serves as a the base class for
	      <link linkend="combobox">combo-boxes</link>.
	    </para>

	    <para>
	      The list layout manager is designed for handling relative large
	      numbers of list entries far more efficiently than if each one
	      was an official <link linkend="labels">label display
		element</link>. The grid layout manager, for example, needs
	      to figure out how to position each display element according
	      to how many columns and rows it spans and figure out how to draw
	      each cell's borders, if it has any. It's quite a bit of work.
	      The list layout manager,
	      on the other hand, has a single list of labels to draw vertically,
	      a much simpler task.
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
	    <link linkend="table"><classname>&ns;::w::tablelayoutmanager</classname></link>
	  </term>
	  <listitem>
	    <para>
	      A list with a header row. The table layout manager offers
	      the optional ability to interactively adjust the relative widths
	      of the columns in the table by moving the border betweens the
	      columns.
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>
	    <link linkend="combobox"><classname>&ns;::w::standard_comboboxlayoutmanager</classname> and <classname>&ns;::w::editable_comboboxlayoutmanager</classname></link>
	  </term>
	  <listitem>
	    <para>
	      These layout managers leverage the list layout manager to quickly
	      deal with the list of choices shown in the combo-box's pop-up,
	      and also deal with the display element that represents the
	      current selection in the combo-box.
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
	    <link linkend="pagelayoutmanager"><classname>&ns;::w::pagelayoutmanager</classname></link>
	  </term>
	  <listitem>
	    <para>
	      Treats its display elements as virtual <quote>pages</quote>,
	      showing one page at a time.
	      <quote>Opening</quote> a different
	      page element replaces the current page's display element with
	      the new element.
	    </para>

	    <para>
	      All elements in this container technically exist, all the time,
	      but only one of the elements is visible at any given time.
	      Each one of page layout manager's display elements is typically
	      a &container; of its own, with a collection of individual
	      display elements. In this manner, each collection of
	      display elements forms a virtual page, and the layout manager's
	      methods make one of its pages visible.
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
	    <link linkend="booklayoutmanager"><classname>&ns;::w::booklayoutmanager</classname></link>
	  </term>
	  <listitem>
	    <para>
	      The book layout manager extends the page layout manager by
	      supplying clickable buttons for each page, that get drawn as
	      tabs in a horizontal strip above the paged container. Clicking
	      on each button tab opens the corresponding page (in the book).
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
	    <link linkend="panelayoutmanager"><classname>&ns;::w::panelayoutmanager</classname></link>
	  </term>
	  <listitem>
	    <para>
	      All elements in this container get arranged into a single
	      row or column. Each element is a resizable <quote>pane</quote>
	      with draggable sliders between the panes dividing the
	      row or column between the panes.
	    </para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>
	The actual layout manager gets specified when creating the container,
	and the return value of <methodname>get_layoutmanager</methodname>()
	gets converted accordingly.
	<link linkend="helloworld"><filename>helloworld.C</filename></link>
	explicitly specifies the grid layout manager for its main window, so
	its <methodname>get_layoutmanager</methodname>() returns a
	<ulink url="&link-typedef-x--w-gridlayoutmanager;"><classname>&ns;::w::gridlayoutmanager</classname></ulink>.
      </para>

      <note>
	<para>
	  The layout manager object returned from
	  <methodname>get_layoutmanager</methodname>() holds several
	  internal locks.
	  Like all other &app; objects, this is a
	  <link linkend="refobjelements">reference-counted object</link>.
	  The internal locks get released
	  when the application finishes using the layout manager, and the
	  last reference to the underlying object goes out of scope and
	  it gets destroyed.
	</para>

	<para>
	  For this reason, the application should not store, or stash away,
	  the layout manager object, but use it only long enough to effect
	  changes to the container, or examine its contents.
	  The internal locks block the
	  <link linkend="connthread">connection thread</link>, until the
	  lock gets released, and all changes made to the container, through
	  the layout manager, take effect. Depending on the layout manager
	  the internal locks may also block other execution thread from
	  accessing the elements in the container.
	</para>

	<para>
	  Retrieving the layout manager, and acquiring any required locks is
	  not cheap, and the application should optimize its access to the
	  layout manager. For the reasons explained the application should
	  not store or stash away the layout manager, persistently; but it
	  should not retrieve it over and over again, to make each individual
	  change to the container. The optimal use pattern is to retrieve
	  the layout manager and make use of it to effect all changes to
	  the container, at once.
	</para>
      </note>
    </section>

    <section id="factory">
      <title>
	Factories
      </title>

      <blockquote>
	<informalexample>
	  <programlisting>
x::w::label l=f->create_label("Hello world");</programlisting>
	</informalexample>
      </blockquote>

      <para>
	An <ulink url="&link-typedef-x--w-factory;"><classname>&ns;::w::factory</classname></ulink>
	creates new display elements. The factory comes from the layout manager,
	and the process for obtaining a factory is specific to each layout
	manager (except for the bare list layout manager, which is an impostor).
	<link linkend="helloworld"><filename>helloworld.C</filename></link>
	calls its grid layout manager's
	<methodname>append_row</methodname>() method, which returns a
	factory that places the new display element in a new row in the grid.
      </para>

      <para>
	Some layout managers provide factories with additional functionality.
	<link linkend="gridlayoutmanager">Grid layout manager</link>'s
	methods return an
	<ulink url="&link-typedef-x--w-gridfactory;"><classname>&ns;::w::gridfactory</classname></ulink>
	with additional methods that set each new element's borders, padding
	and alignment.
      </para>

      <note>
	<para>
	  Factories are products of layout managers, and maintain an internal
	  reference on their layout manager. Everything that's been said
	  about layout managers apply to factories as well: the factory
	  object should be used only long enough to manufacture new
	  display elements; then they should go out of scope and get
	  destroyed, releasing their internal reference to their layout
	  manager, and releasing the indirect reference on their container,
	  unblocking it.
	</para>
      </note>
    </section>

    <section id="exception">
      <title>Exceptions</title>

      <para>
	Fatal errors in the &app; get reported by throwing an
	<ulink url="/exceptions"><classname>&ns;::exception</classname></ulink>
	&libcxx; object.
	<link linkend="helloworld"><filename>helloworld.C</filename></link>
	shows the basic approach of catching the exception, and reporting it.
      </para>
    </section>
  </section>
</chapter>
<!--
Local Variables:
mode: sgml
sgml-parent-document: ("book.xml" "book" "chapter")
End:
-->
